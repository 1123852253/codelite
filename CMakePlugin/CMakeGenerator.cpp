//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// copyright            : (C) 2014 Eran Ifrah
// file name            : CMakeGenerator.cpp
//
// -------------------------------------------------------------------------
// A
//              _____           _      _     _ _
//             /  __ \         | |    | |   (_) |
//             | /  \/ ___   __| | ___| |    _| |_ ___
//             | |    / _ \ / _  |/ _ \ |   | | __/ _ )
//             | \__/\ (_) | (_| |  __/ |___| | ||  __/
//              \____/\___/ \__,_|\___\_____/_|\__\___|
//
//                                                  F i l e
//
//    This program is free software; you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation; either version 2 of the License, or
//    (at your option) any later version.
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

/* ************************************************************************ */
/*                                                                          */
/* CMakePlugin for Codelite                                                 */
/* Copyright (C) 2013 Jiří Fatka <ntsfka@gmail.com>                         */
/*                                                                          */
/* This program is free software: you can redistribute it and/or modify     */
/* it under the terms of the GNU General Public License as published by     */
/* the Free Software Foundation, either version 3 of the License, or        */
/* (at your option) any later version.                                      */
/*                                                                          */
/* This program is distributed in the hope that it will be useful,          */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of           */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             */
/* GNU General Public License for more details.                             */
/*                                                                          */
/* You should have received a copy of the GNU General Public License        */
/* along with this program. If not, see <http://www.gnu.org/licenses/>.     */
/*                                                                          */
/* ************************************************************************ */

/* ************************************************************************ */
/* INCLUDES                                                                 */
/* ************************************************************************ */

// Declarations
#include "CMakeGenerator.h"
#include "fileextmanager.h"
#include "fileutils.h"

// wxWidgets
#include <wx/tokenzr.h>
#include <wx/ffile.h>
#include <wx/filename.h>
#include <wx/msgdlg.h>

// Plugin
#include "CMakePlugin.h"
#include "globals.h"

#define CODELITE_CMAKE_PREFIX "# -*- CMakeLists.txt generated by CodeLite IDE. Do not edit by hand -*-"
size_t CMakeGenerator::m_counter = 0;

/* ************************************************************************ */
/* FUNCTIONS                                                                */
/* ************************************************************************ */

/**
 * @brief Check if filename exists and asks if user want it overwrite if
 * exists.
 *
 * @param filename Tested filename.
 *
 * @return If file can be written.
 */
static bool CheckExists(const wxFileName& filename)
{
    // Output file exists, overwrite?
    if(filename.Exists()) {
        wxString msg;
        msg << CMakePlugin::CMAKELISTS_FILE << " exists. Overwrite?\n"
            << "(" << filename.GetFullPath() << ")";
        wxStandardID answer = ::PromptForYesNoDialogWithCheckbox(msg, "CMakePluginOverwriteDlg", _("Overwrite"),
            _("Don't Overwrite"), _("Remember my answer and don't annoy me again"),
            wxYES_NO | wxCANCEL | wxCENTER | wxICON_QUESTION | wxYES_DEFAULT);
        return (answer == wxID_YES);
    }

    // File doesn't exists, write it
    return true;
}

/* ************************************************************************ */
/* CLASSES                                                                  */
/* ************************************************************************ */

bool CMakeGenerator::Generate(clCxxWorkspace* workspace)
{
    m_counter = 0;
    if(!workspace) return false;

    // Export all projects
    wxArrayString projectsArr;
    workspace->GetProjectList(projectsArr);

    for(size_t i = 0; i < projectsArr.GetCount(); ++i) {
        ProjectPtr pProj = workspace->GetProject(projectsArr.Item(i));
        Generate(pProj, false);
    }

    // ====----------------------------
    // Now generate the workspace
    // ====----------------------------
    // Get workspace directory.
    const wxFileName workspaceDir = workspace->GetWorkspaceFileName().GetPath(wxPATH_GET_SEPARATOR | wxPATH_GET_VOLUME);

    // Output file name
    const wxFileName filename(workspaceDir.GetPath(), CMakePlugin::CMAKELISTS_FILE);

    if(!CheckExists(filename)) return false;

    // File content
    wxString content;

    // Print project name
    content << CODELITE_CMAKE_PREFIX << "\n\n";
    content << "cmake_minimum_required(VERSION 2.8.11)\n\n";
    content << "# Workspace name\n";
    content << "project(" << workspace->GetName() << ")\n\n";

    // Environment variables
    {
        wxString variables = workspace->GetEnvironmentVariabels(); // Nice typo
        variables.Trim().Trim(false);

        if(!variables.IsEmpty()) {
            // Split into a list of pairs
            const wxArrayString list = wxStringTokenize(variables, "\n;");

            for(wxArrayString::const_iterator it = list.begin(), ite = list.end(); it != ite; ++it) {
                // Split into name, value pair
                const wxArrayString pair = wxSplit(*it, '=');

                const wxString& name = pair[0];
                const wxString value = (pair.GetCount() >= 2) ? pair[1] : "";

                // Set environment variable
                content << "set(" << name << " \"" << value << "\")\n";
            }

            content << "\n";
        }
    }

    content << "# Projects\n";

    // Get full paths to all projects
    const wxArrayString projects = workspace->GetAllProjectPaths();

    // Foreach projects path
    for(wxArrayString::const_iterator it = projects.begin(), ite = projects.end(); it != ite; ++it) {
        wxFileName fullpath = *it;
        fullpath.MakeRelativeTo(workspaceDir.GetPath());

        // Create path to CMakeLists.txt in the project
        const wxFileName cmakelist(fullpath.GetPath(), CMakePlugin::CMAKELISTS_FILE);

        // Skip directories without CMakeLists.txt
        if(!cmakelist.Exists()) continue;

        // Write
        wxString projectDir = fullpath.GetPath();
        if(projectDir.IsEmpty()) projectDir = ".";
        content << "add_subdirectory(" << projectDir << ")\n";
    }

    // Write result
    FileUtils::WriteFileContent(filename, content);
    return true;
}

/* ************************************************************************ */

bool CMakeGenerator::Generate(ProjectPtr project, bool topProject, const wxString& configName)
{
    wxASSERT(project);

    // Sources are kept relative in the project
    // we need to fix this
    Project::FileInfoVector_t vfiles;
    project->GetFilesMetadata(vfiles);

    wxArrayString cppSources, cSources;
    wxString workspacePath = clCxxWorkspaceST::Get()->GetFileName().GetPath();
    std::for_each(vfiles.begin(), vfiles.end(), [&](const Project::FileInfo& fi) {
        wxFileName fn(fi.GetFilename());

        // Make it relative to the workspace
        fn.MakeRelativeTo(workspacePath);

        // Append each file with the "${CMAKE_SOURCE_DIR}/" prefix
        wxString file_name;
        file_name << "${CMAKE_SOURCE_DIR}/" << fn.GetFullPath();
        file_name.Replace("\\", "/");
        if(FileExtManager::GetType(fn.GetFullName()) == FileExtManager::TypeSourceC) {
            cSources.Add(file_name);
        } else if(FileExtManager::GetType(fn.GetFullName()) == FileExtManager::TypeSourceCpp) {
            cppSources.Add(file_name);
        }
    });

    // Get project directory
    wxString projectDir = project->GetFileName().GetPath();

    // Get the project build configuration and compiler
    BuildConfigPtr buildConf = project->GetBuildConfiguration(configName);

    // Sanity
    if(!buildConf || buildConf->IsCustomBuild()) {
        // no build config or custom build?
        return false;
    }

    CompilerPtr compiler = buildConf->GetCompiler();
    if(!compiler) {
        return false;
    }

    wxFileName projectPath = project->GetFileName();
    wxArrayString depsPaths;
    wxArrayString depsProjectNames;
    if(topProject) {
        wxArrayString depsProjects = project->GetDependencies(buildConf->GetName());
        for(size_t i = 0; i < depsProjects.GetCount(); ++i) {
            ProjectPtr pProj = clCxxWorkspaceST::Get()->GetProject(depsProjects.Item(i));
            if(pProj) {
                if(Generate(pProj, false)) {
                    wxString depProjFilePath = pProj->GetFileName().GetFullPath();
                    wxFileName fnDepProj(depProjFilePath);
                    fnDepProj.MakeRelativeTo(projectPath.GetPath());
                    wxString relPath = fnDepProj.GetPath(false, wxPATH_UNIX);

                    // Keep the project path relative to current project
                    depsPaths.Add(relPath);

                    // Keep the project name
                    depsProjectNames.Add(pProj->GetName());
                }
            }
        }
    }

    // Output file name
    wxFileName filename(projectDir, CMakePlugin::CMAKELISTS_FILE);

    if(!CheckExists(filename)) return false;

    // File content
    wxString content;

    content << CODELITE_CMAKE_PREFIX << "\n\n";
    content << "cmake_minimum_required(VERSION 2.8.11)\n\n";

    // Print project name
    content << "project(" << project->GetName() << ")\n\n";

    // Add the dependencies first
    if(!depsPaths.IsEmpty()) {
        content << "# Add the build order directories\n";
    }

    for(size_t i = 0; i < depsPaths.GetCount(); ++i) {
        content << "add_subdirectory( " << depsPaths.Item(i) << " )\n";
    }
    content << "\n\n";

    // Add include directories
    {
        wxArrayString includes = ::wxStringTokenize(buildConf->GetIncludePath(), ";", wxTOKEN_STRTOK);
        content << "include_directories(\n";
        for(size_t i = 0; i < includes.GetCount(); ++i) {

            wxString& includePath = includes.Item(i);
            includePath.Replace("\\", "/");
            includePath.Trim(false).Trim();
            if(includePath.IsEmpty()) {
                continue;
            }
            content << "    " << includes.Item(i) << "\n";
        }
        content << "\n)\n\n";
    }

    // Add custom command from the compiler options
    {
        wxArrayString optsNames, opts;
        content << "\n#Compiler options\n";

        wxString cxxCmpOptions = buildConf->GetCompileOptions();
        ExpandOptions(cxxCmpOptions, content, optsNames, opts);
        for(size_t i = 0; i < optsNames.size(); ++i) {
            content << "add_definitions(${" << optsNames.Item(i) << "})\n";
        }
        for(size_t i = 0; i < opts.size(); ++i) {
            content << "add_definitions(" << opts.Item(i) << ")\n";
        }

        wxString cCmpOptions = buildConf->GetCCompileOptions();
        ExpandOptions(cCmpOptions, content, optsNames, opts);
        for(size_t i = 0; i < optsNames.size(); ++i) {
            content << "add_definitions(${" << optsNames.Item(i) << "})\n";
        }
        for(size_t i = 0; i < opts.size(); ++i) {
            content << "add_definitions(" << opts.Item(i) << ")\n";
        }
    }

    // Add preprocessor definitions
    {
        wxArrayString defines = project->GetPreProcessors(false);
        if(!defines.IsEmpty()) {
            content << "add_definitions(\n";
            for(size_t i = 0; i < defines.GetCount(); ++i) {
                wxString& pp = defines.Item(i);
                pp.Trim().Trim(false);
                if(pp.IsEmpty()) {
                    continue;
                }
                content << "    -D" << pp << "\n";
            }
            content << ")\n\n";
        }
    }

    // Add linker options
    {
        wxArrayString optsNames, opts;
        wxString linkOptions = buildConf->GetLinkOptions();
        content << "\n# Linker options\n";
        ExpandOptions(linkOptions, content, optsNames, opts);
        bool first = true;
        for(size_t i = 0; i < optsNames.size(); ++i) {
            content << "set(LINK_OPTIONS " << (first ? "" : "${LINK_OPTIONS} ") << "${" << optsNames.Item(i) << "})\n";
            first = false;
        }

        for(size_t i = 0; i < opts.size(); ++i) {
            content << "set(LINK_OPTIONS " << (first ? "" : "${LINK_OPTIONS} ") << opts.Item(i) << ")\n";
            first = false;
        }
        content << "\n";
    }

    // Add libraries paths
    {
        wxString lib_paths = buildConf->GetLibPath();
        wxString lib_switch = "-L";

        // Get switch from compiler
        if(compiler) {
            lib_switch = compiler->GetSwitch("LibraryPath");

            // Append global library paths
            lib_paths << ";" << compiler->GetGlobalLibPath();
        }

        // to replace all instances of backslashes with forward slashes issue #1073
        lib_paths.Replace("\\", "/");
        lib_paths.Trim(false).Trim();
        // Get list of library paths
        wxArrayString lib_paths_list = wxStringTokenize(lib_paths, ";", wxTOKEN_STRTOK);

        // Clear string
        lib_paths.Clear();

        // Append modified values
        for(size_t i = 0; i < lib_paths_list.GetCount(); ++i) {
            lib_paths << lib_switch << "\\\"" << lib_paths_list.Item(i) << "\\\" ";
        }

        content << "# Library path\n";
        content << "set(CMAKE_LDFLAGS \"${CMAKE_LDFLAGS} " << lib_paths << "\")\n\n";
    }

    // Write sources
    {
        if(!cSources.IsEmpty()) {
            content << "# Define the C sources\n";
            content << "set ( C_SRCS\n";
            for(size_t i = 0; i < cSources.GetCount(); ++i) {
                content << "    " << cSources.Item(i) << "\n";
            }
            content << ")\n\n";
        }

        if(!cppSources.IsEmpty()) {
            content << "# Define the CXX sources\n";
            content << "set ( CXX_SRCS\n";
            for(size_t i = 0; i < cppSources.GetCount(); ++i) {
                content << "    " << cppSources.Item(i) << "\n";
            }
            content << ")\n\n";
        }
    }

    // Add CXX compiler options
    {
        wxArrayString buildOptsArr = project->GetCXXCompilerOptions();
        if(!buildOptsArr.IsEmpty() && !cppSources.IsEmpty()) {
            content << "set_source_files_properties(\n    ${CXX_SRCS} PROPERTIES COMPILE_FLAGS \n    \"";
            for(size_t i = 0; i < buildOptsArr.GetCount(); ++i) {
                content << " " << buildOptsArr.Item(i);
            }
            content << "\")\n\n";
        }
    }

    // Add C compiler options
    {
        wxArrayString buildOptsArr = project->GetCCompilerOptions();
        if(!buildOptsArr.IsEmpty() && !cSources.IsEmpty()) {
            content << "set_source_files_properties(\n    ${C_SRCS} PROPERTIES COMPILE_FLAGS \n    \"";
            for(size_t i = 0; i < buildOptsArr.GetCount(); ++i) {
                content << " " << buildOptsArr.Item(i);
            }
            content << "\")\n\n";
        }
    }

    // Get project type
    {
        wxString type = buildConf->GetProjectType();
        if(type == Project::EXECUTABLE) {
            content << "add_executable(" << project->GetName() << " ${CXX_SRCS} ${C_SRCS})\n";
            content << "target_link_libraries(" << project->GetName() << " ${LINK_OPTIONS})\n\n";

        } else if(type == Project::DYNAMIC_LIBRARY) {
            content << "add_library(" << project->GetName() << " SHARED ${CXX_SRCS} ${C_SRCS})\n";
            content << "target_link_libraries(" << project->GetName() << " ${LINK_OPTIONS})\n\n";

        } else {
            content << "add_library(" << project->GetName() << " ${CXX_SRCS} ${C_SRCS})\n\n";
        }
    }

    // Add link libraries
    {
        wxString libs = buildConf->GetLibraries();

        libs.Trim().Trim(false);

        if(!libs.IsEmpty()) {
            libs.Replace(";", "\n    ");
            content << "target_link_libraries(" << project->GetName() << "\n    " << libs << "\n)\n\n";
        }
    }

    // And setup the deps
    // Set up a dependecy between the this project and the subproject
    if(!depsProjectNames.IsEmpty()) {
        content << "# Setup dependencies\n";
    }
    for(size_t i = 0; i < depsProjectNames.GetCount(); ++i) {
        content << "add_dependencies( " << project->GetName() << " " << depsProjectNames.Item(i) << " )\n";
    }

    // Write result
    FileUtils::WriteFileContent(filename, content);
    return true;
}

bool CMakeGenerator::CanGenerate(clCxxWorkspace* workspace)
{
    wxASSERT(workspace);
    wxFileName workspaceFile = workspace->GetFileName();
    std::vector<wxFileName> cmakelistsArr;
    cmakelistsArr.push_back(wxFileName(workspaceFile.GetPath(), CMakePlugin::CMAKELISTS_FILE));

    // Add the projects
    wxArrayString projects;
    workspace->GetProjectList(projects);
    for(size_t i = 0; i < projects.size(); ++i) {
        ProjectPtr p = workspace->GetProject(projects.Item(i));
        if(p) {
            cmakelistsArr.push_back(wxFileName(p->GetFileName().GetPath(), CMakePlugin::CMAKELISTS_FILE));
        }
    }

    // Read each of the CMakeLists.txt file in the array, and check if we can find our top level comment
    for(size_t i = 0; i < cmakelistsArr.size(); ++i) {
        const wxFileName& fn = cmakelistsArr.at(i);
        wxString content;
        if(fn.Exists() && FileUtils::ReadFileContent(fn, content)) {
            if(!content.StartsWith(CODELITE_CMAKE_PREFIX)) {
                return false;
            }
        }
    }
    return true;
}

void CMakeGenerator::ExpandOptions(
    const wxString& options, wxString& content, wxArrayString& arrVars, wxArrayString& arrOut)
{
    arrVars.clear();
    arrOut.clear();

    wxArrayString arrOptions = ::wxStringTokenize(options, ";", wxTOKEN_STRTOK);
    for(size_t i = 0; i < arrOptions.size(); ++i) {
        wxString cmpOption(arrOptions.Item(i));
        cmpOption.Trim().Trim(false);
        wxString tmp;
        // Expand backticks / $(shell ...) syntax supported by CodeLite
        if(cmpOption.StartsWith(wxT("$(shell "), &tmp) || cmpOption.StartsWith(wxT("`"), &tmp)) {
            cmpOption.swap(tmp);
            tmp.Clear();
            if(cmpOption.EndsWith(wxT(")"), &tmp) || cmpOption.EndsWith(wxT("`"), &tmp)) {
                cmpOption.swap(tmp);
            }

            wxString varname;
            varname << "CL_VAR_" << (++m_counter);
            // Create a CMake command that executes this command
            content << "execute_process(COMMAND \n    " << cmpOption << "\n    OUTPUT_VARIABLE\n    CL_TMP_VAR"
                    << "\n    OUTPUT_STRIP_TRAILING_WHITESPACE)\n";
            content << "string(STRIP ${CL_TMP_VAR} " << varname << ")\n";
            arrVars.Add(varname);
        } else {
            arrOut.Add(cmpOption); // Keep as is
        }
    }
}
